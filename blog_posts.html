<!DOCTYPE html>
<html>
<head>
	<title>Tech-Asteroid Blog</title>
	<link rel="stylesheet" href="/css/blog.css">
	<meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=yes">
</head>
<body>
	<header>
		<img src="/images/logo-background-new.png" alt="" class="logo">
		<span id="companyName">Blog</span>
		<span class="headerUl">
			<ul class="headerList">
				<a href="https://tech-asteroid.com/index.html"><li>tech-asteroid.com</li></a>
			</ul>
		</span>
	</header>
	<div class="container">
		<div id="blogContent">
			<div class='aboutMe'><p>Welcome to my blog.</p><p> <span class='disclaimer'>DISCLAIMER:</span> Anything you read here is often just my opinion and therefore potentially wrong, outdated, or not in sync with your opinions.</p></div>
			<div class="bposts"><a href="scrolljack.html"><div class="bpostListing"><p class="bpostTitle">Scroll-Jacking Aka Annoying Your User Base</p><pre class="sneakPeak">This post will serve as a warning to prospective designers and programmers that are thinking of using scroll-jacking inside their projects. If this post prevents even one website from using this technique, my words will have served a valuable service. The plain fact of the matter is, there is no functionality that you should need to implement that depends on overriding the default scrolling behaviour of the users' browser. At best, you will have spent significant time making a very good scrolling experience across all OSes and browsers. Considering most users are going to be accustomed to their native os/browser scrolling experience, more than likely your custom scrolling behaviour is going to be viewed as cumbersome and annoying. Your time is better spent elsewhere, and the user can trust that they will get the native experience while using your resource.</pre><p class="bpostDate">Sunday, November 20th, 2016</p></div></a><a href="joeltest.html"><div class="bpostListing"><p class="bpostTitle">Thoughts on the Joel Test (in 2016) </p><pre class="sneakPeak">Thoughts on the Joel Test for evaluating employers.</pre><p class="bpostDate">Thursday, October 20th, 2016</p></div></a><a href="integration.html"><div class="bpostListing"><p class="bpostTitle">Integration (System) Testing vs Unit Testing</p><pre class="sneakPeak">The utility of integration (system) tests cannot be overstated for stabilizing an API and ensuring reliable functionality. My experience with unit tests have shown them to be brittle, susceptible to coupling, and often the source of frustrating refactoring and debugging experiences. The modern age of computing has all but eliminated the costs of running thorough integration tests on the core API of your code. Using parallelization with modern hardware and or cloud resources, it is possible to continuously run system tests that achieve high levels of coverage across your API in real-life data scenarios. This data can often be much more informative as it suggests how the entire code of the system works together rather than out of context.</pre><p class="bpostDate">Thursday, September 15th, 2016</p></div></a><a href="error.html"><div class="bpostListing"><p class="bpostTitle">Error Handling</p><pre class="sneakPeak">Error handling is an integral skill that developers should be actively developing from the very beginning of their careers. Skillful error handling results in robust applications, and more enjoyable user/debugging sessions. While masterful error handling may not be immediately obvious to users and developers, poor error handling is a glaring sore thumb to everyone involved with the software. The three most common pitfalls of error handling in my experience are indescriptive/misleading error messages, confusing stack traces, and absent recovery logic.</pre><p class="bpostDate">Thursday, April 28th, 2016</p></div></a><a href="ai.html"><div class="bpostListing"><p class="bpostTitle">AI</p><pre class="sneakPeak">The rise of AI is nothing short of amazing. Many of those whom had either a passing interest in Chess or computers were aware of the 1997 rematch between Deep Blue and world champion GM Garry Kasparov. This match was the first time artificial intelligence was able to defeat a reigning world chess champion under tournament conditions.&lt;a href='https://en.wikipedia.org/wiki/Deep_Blue_versus_Kasparov,_1997,_Game_6'&gt; (Deep Blue Vs Kasparov Wiki Article) &lt;/a&gt;. While this was seen as an impressive rise in artificial intelligence programming, it was only a mere indication of the AI to come.</pre><p class="bpostDate">Saturday, March 19th, 2016</p></div></a><a href="es6.html"><div class="bpostListing"><p class="bpostTitle">ES6</p><pre class="sneakPeak">A very important milestone was reached yesterday with the release of Firefox 45. Firefox 45 now natively supports ES6 class syntax, and the current big three of browsers (Firefox, Chrome, and Edge) now support all the major ES6 conventions natively. &lt;a href='https://kangax.github.io/compat-table/es6/'&gt;ES6 Compatibility Table&lt;/a&gt;</pre><p class="bpostDate">Wednesday, March 9th, 2016</p></div></a><a href="linux.html"><div class="bpostListing"><p class="bpostTitle">Linux</p><pre class="sneakPeak">Linus Torvalds is infamous for having stated 'If Microsoft ever does applications for Linux it means I've won.' If we measure his success simply based on this fact, then it is clear he has won handedly. Microsoft is currently releasing much of their product line to be compatible with Linux distributions to try to get a piece of the licensing revenue. But in many regards I think Linux has surpassed the wildest expectations that Linus originally had for his Unix based OS.</pre><p class="bpostDate">Wednesday, February 10th, 2016</p></div></a></div>
			
		</div>
		<div id="disqus_thread"></div>
		<script>
		(function() {
		var d = document, s = d.createElement('script');
		s.src = '//virtual-machine.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
		})();
		</script>
		<noscript>Please enable JavaScript to view comments</noscript>	
	</div>
</body>
</html>